<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Numerics.Tensors</name>
    </assembly>
    <members>
        <member name="T:System.Numerics.Tensors.TensorPrimitives">
            <summary>Performs primitive tensor operations over spans of memory.</summary>
            <summary>Performs primitive tensor operations over spans of memory.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Abs(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise absolute value of each single-precision floating-point number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = MathF.Abs(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The absolute value of a <see cref="T:System.Single"/> is its numeric value without its sign. For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.
            </para>
            <para>
            If a value is equal to <see cref="F:System.Single.NegativeInfinity"/> or <see cref="F:System.Single.PositiveInfinity"/>, the result stored into the corresponding destination location is set to <see cref="F:System.Single.PositiveInfinity"/>.
            If a value is equal to <see cref="F:System.Single.NaN"/>, the result stored into the corresponding destination location is the original NaN value with the sign bit removed.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Add(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise addition of single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Add(System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})">
            <summary>Computes the element-wise addition of single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + <paramref name="y" /></c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="multiplier">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" /> and the length of <paramref name="multiplier" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="multiplier"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />[i]) * <paramref name="multiplier" />[i]</c>.
            </para>
            <para>
            If any of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="multiplier">The third tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />[i]) * <paramref name="multiplier" /></c>.
            </para>
            <para>
            If any of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply(System.ReadOnlySpan{System.Single},System.Single,System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="multiplier">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="multiplier" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="multiplier"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />) * <paramref name="multiplier" />[i]</c>.
            </para>
            <para>
            If any of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Cosh(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise hyperbolic cosine of each single-precision floating-point radian angle in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Cosh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value is equal to <see cref="F:System.Single.NegativeInfinity"/> or <see cref="F:System.Single.PositiveInfinity"/>, the result stored into the corresponding destination location is set to <see cref="F:System.Single.PositiveInfinity"/>.
            If a value is equal to <see cref="F:System.Single.NaN"/>, the result stored into the corresponding destination location is also NaN.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians"/> or multiply by <see cref="F:System.MathF.PI"/>/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CosineSimilarity(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})">
            <summary>Computes the cosine similarity between the two specified non-empty, equal-length tensors of single-precision floating-point numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The cosine similarity of the two tensors.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
            <remarks>
            <para>
            This method effectively computes <c>TensorPrimitives.Dot(x, y) / (MathF.Sqrt(TensorPrimitives.SumOfSquares(x)) * MathF.Sqrt(TensorPrimitives.SumOfSquares(y)).</c>
            </para>
            <para>
            If any element in either input tensor is equal to <see cref="F:System.Single.NegativeInfinity"/>, <see cref="F:System.Single.PositiveInfinity"/>, or <see cref="F:System.Single.NaN"/>,
            NaN is returned.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Distance(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})">
            <summary>Computes the distance between two points, specified as non-empty, equal-length tensors of single-precision floating-point numbers, in Euclidean space.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The Euclidean distance.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
            <remarks>
            <para>
            This method effectively computes the equivalent of:
            <c>
                Span&lt;float&gt; difference = ...;
                TensorPrimitives.Subtract(x, y, difference);
                float result = MathF.Sqrt(TensorPrimitives.SumOfSquares(difference));
            </c>
            but without requiring additional temporary storage for the intermediate differences.
            </para>
            <para>
            If any element in either input tensor is equal to <see cref="F:System.Single.NaN"/>, NaN is returned.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Divide(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise division of single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] / <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Divide(System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})">
            <summary>Computes the element-wise division of single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] / <paramref name="y" /></c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Dot(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})">
            <summary>Computes the dot product of two tensors containing single-precision floating-point numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The dot product.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <remarks>
            <para>
            This method effectively computes the equivalent of:
            <c>
                Span&lt;float&gt; products = ...;
                TensorPrimitives.Multiply(x, y, products);
                float result = TensorPrimitives.Sum(products);
            </c>
            but without requiring additional temporary storage for the intermediate products. It corresponds to the <c>dot</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If any of the input elements is equal to <see cref="F:System.Single.NaN"/>, the resulting value is also NaN.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Exp(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise result of raising <c>e</c> to the single-precision floating-point number powers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Exp(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals <see cref="F:System.Single.NaN"/> or <see cref="F:System.Single.PositiveInfinity"/>, the result stored into the corresponding destination location is set to NaN.
            If a value equals <see cref="F:System.Single.NegativeInfinity"/>, the result stored into the corresponding destination location is set to 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMax(System.ReadOnlySpan{System.Single})">
            <summary>Searches for the index of the largest single-precision floating-point number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The index of the maximum element in <paramref name="x"/>, or -1 if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If any value equal to <see cref="F:System.Single.NaN"/>
            is present, the index of the first is returned. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMaxMagnitude(System.ReadOnlySpan{System.Single})">
            <summary>Searches for the index of the single-precision floating-point number with the largest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The index of the element in <paramref name="x"/> with the largest magnitude (absolute value), or -1 if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitude` function. If any value equal to <see cref="F:System.Single.NaN"/>
            is present, the index of the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMin(System.ReadOnlySpan{System.Single})">
            <summary>Searches for the index of the smallest single-precision floating-point number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The index of the minimum element in <paramref name="x"/>, or -1 if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimum` function. If any value equal to <see cref="F:System.Single.NaN"/>
            is present, the index of the first is returned. Negative 0 is considered smaller than positive 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMinMagnitude(System.ReadOnlySpan{System.Single})">
            <summary>Searches for the index of the single-precision floating-point number with the smallest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The index of the element in <paramref name="x"/> with the smallest magnitude (absolute value), or -1 if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If any value equal to <see cref="F:System.Single.NaN"/>
            is present, the index of the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise natural (base <c>e</c>) logarithm of single-precision floating-point numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Log(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="F:System.Single.NegativeInfinity"/>.
            If a value is negative or equal to <see cref="F:System.Single.NaN"/>, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="F:System.Single.PositiveInfinity"/>.
            Otherwise, if a value is positive, its natural logarithm is stored into the corresponding destination location.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log2(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise base 2 logarithm of single-precision floating-point numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Log2(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="F:System.Single.NegativeInfinity"/>.
            If a value is negative or equal to <see cref="F:System.Single.NaN"/>, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="F:System.Single.PositiveInfinity"/>.
            Otherwise, if a value is positive, its natural logarithm is stored into the corresponding destination location.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Max(System.ReadOnlySpan{System.Single})">
            <summary>Searches for the largest single-precision floating-point number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The maximum element in <paramref name="x"/>.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If any value equal to <see cref="F:System.Single.NaN"/>
            is present, the first is returned. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Max(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise maximum of the single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = MathF.Max(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="F:System.Single.NaN"/>,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude(System.ReadOnlySpan{System.Single})">
            <summary>Searches for the single-precision floating-point number with the largest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The element in <paramref name="x"/> with the largest magnitude (absolute value).</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitude` function. If any value equal to <see cref="F:System.Single.NaN"/>
            is present, the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise single-precision floating-point number with the largest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>This method effectively computes <c><paramref name="destination" />[i] = MathF.MaxMagnitude(<paramref name="x" />[i], <paramref name="y" />[i])</c>.</remarks>
            <remarks>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Min(System.ReadOnlySpan{System.Single})">
            <summary>Searches for the smallest single-precision floating-point number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The minimum element in <paramref name="x"/>.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimum` function. If any value is equal to <see cref="F:System.Single.NaN"/>
            is present, the first is returned. Negative 0 is considered smaller than positive 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Min(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise minimum of the single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = MathF.Max(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="F:System.Single.NaN"/>,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude(System.ReadOnlySpan{System.Single})">
            <summary>Searches for the single-precision floating-point number with the smallest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The element in <paramref name="x"/> with the smallest magnitude (absolute value).</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If any value equal to <see cref="F:System.Single.NaN"/>
            is present, the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise single-precision floating-point number with the smallest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>This method effectively computes <c><paramref name="destination" />[i] = MathF.MinMagnitude(<paramref name="x" />[i], <paramref name="y" />[i])</c>.</remarks>
            <remarks>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If either value is equal to <see cref="F:System.Single.NaN"/>,
            that value is stored as the result. If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Multiply(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise product of single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] * <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Multiply(System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})">
            <summary>Computes the element-wise product of single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] * <paramref name="y" /></c>.
            It corresponds to the <c>scal</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) * <paramref name="addend" /></c> for the specified tensors of single-precision floating-point numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="addend">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" /> and length of <paramref name="addend" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="addend"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) * <paramref name="addend" /></c> for the specified tensors of single-precision floating-point numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="addend">The third tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" /></c>.
            It corresponds to the <c>axpy</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd(System.ReadOnlySpan{System.Single},System.Single,System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) * <paramref name="addend" /></c> for the specified tensors of single-precision floating-point numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="addend">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="addend" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="addend"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />) + <paramref name="addend" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Negate(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise negation of each single-precision floating-point number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = -<paramref name="x" />[i]</c>.
            </para>
            <para>
            If any of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Norm(System.ReadOnlySpan{System.Single})">
            <summary>Computes the Euclidean norm of the specified tensor of single-precision floating-point numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <returns>The norm.</returns>
            <remarks>
            <para>
            This method effectively computes <c>MathF.Sqrt(TensorPrimitives.SumOfSquares(x))</c>.
            This is often referred to as the Euclidean norm or L2 norm.
            It corresponds to the <c>nrm2</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If any of the input values is equal to <see cref="F:System.Single.NaN"/>, the result value is also NaN.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Product(System.ReadOnlySpan{System.Single})">
            <summary>Computes the product of all elements in the specified non-empty tensor of single-precision floating-point numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The result of multiplying all elements in <paramref name="x"/>.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            If any of the input values is equal to <see cref="F:System.Single.NaN"/>, the result value is also NaN.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ProductOfDifferences(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})">
            <summary>Computes the product of the element-wise differences of the single-precision floating-point numbers in the specified non-empty tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The result of multiplying the element-wise subtraction of the elements in the second tensor from the first tensor.</returns>
            <exception cref="T:System.ArgumentException">Length of both input spans must be greater than zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="y"/> must have the same length.</exception>
            <remarks>
            <para>
            This method effectively computes:
            <c>
                Span&lt;float&gt; differences = ...;
                TensorPrimitives.Subtract(x, y, differences);
                float result = TensorPrimitives.Product(differences);
            </c>
            but without requiring additional temporary storage for the intermediate differences.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ProductOfSums(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})">
            <summary>Computes the product of the element-wise sums of the single-precision floating-point numbers in the specified non-empty tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The result of multiplying the element-wise additions of the elements in each tensor.</returns>
            <exception cref="T:System.ArgumentException">Length of both input spans must be greater than zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="y"/> must have the same length.</exception>
            <remarks>
            <para>
            This method effectively computes:
            <c>
                Span&lt;float&gt; sums = ...;
                TensorPrimitives.Add(x, y, sums);
                float result = TensorPrimitives.Product(sums);
            </c>
            but without requiring additional temporary storage for the intermediate sums.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sigmoid(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise sigmoid function on the specified non-empty tensor of single-precision floating-point numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> must not be empty.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1f / (1f + <see cref="T:System.MathF" />.Exp(-<paramref name="x" />[i]))</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sinh(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise hyperbolic sine of each single-precision floating-point radian angle in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Sinh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value is equal to <see cref="F:System.Single.NegativeInfinity"/>, <see cref="F:System.Single.PositiveInfinity"/>, or <see cref="F:System.Single.NaN"/>,
            the corresponding destination location is set to that value.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians"/> or multiply by <see cref="F:System.MathF.PI"/>/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SoftMax(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the softmax function over the specified non-empty tensor of single-precision floating-point numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> must not be empty.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes a sum of <c>MathF.Exp(x[i])</c> for all elements in <paramref name="x"/>.
            It then effectively computes <c><paramref name="destination" />[i] = MathF.Exp(<paramref name="x" />[i]) / sum</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Subtract(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise difference between single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Subtract(System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})">
            <summary>Computes the element-wise difference between single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - <paramref name="y" /></c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sum(System.ReadOnlySpan{System.Single})">
            <summary>Computes the sum of all elements in the specified tensor of single-precision floating-point numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The result of adding all elements in <paramref name="x"/>, or zero if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            If any of the values in the input is equal to <see cref="F:System.Single.NaN"/>, the result is also NaN.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SumOfMagnitudes(System.ReadOnlySpan{System.Single})">
            <summary>Computes the sum of the absolute values of every element in the specified tensor of single-precision floating-point numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The result of adding the absolute value of every element in <paramref name="x"/>, or zero if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            This method effectively computes:
            <c>
                Span&lt;float&gt; absoluteValues = ...;
                TensorPrimitives.Abs(x, absoluteValues);
                float result = TensorPrimitives.Sum(absoluteValues);
            </c>
            but without requiring intermediate storage for the absolute values. It corresponds to the <c>asum</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SumOfSquares(System.ReadOnlySpan{System.Single})">
            <summary>Computes the sum of the square of every element in the specified tensor of single-precision floating-point numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The result of adding the square of every element in <paramref name="x"/>, or zero if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            This method effectively computes:
            <c>
                Span&lt;float&gt; squaredValues = ...;
                TensorPrimitives.Multiply(x, x, squaredValues);
                float result = TensorPrimitives.Sum(squaredValues);
            </c>
            but without requiring intermediate storage for the squared values.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Tanh(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise hyperbolic tangent of each single-precision floating-point radian angle in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Tanh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value is equal to <see cref="F:System.Single.NegativeInfinity"/>, the corresponding destination location is set to -1.
            If a value is equal to <see cref="F:System.Single.PositiveInfinity"/>, the corresponding destination location is set to 1.
            If a value is equal to <see cref="F:System.Single.NaN"/>, the corresponding destination location is set to NaN.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians"/> or multiply by <see cref="F:System.MathF.PI"/>/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ValidateInputOutputSpanNonOverlapping``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Throws an exception if the <paramref name="input"/> and <paramref name="output"/> spans overlap and don't begin at the same memory location.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ThrowNegateTwosCompOverflow">
            <summary>Throws an <see cref="T:System.OverflowException"/> for trying to negate the minimum value of a two-complement value.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.TensorPrimitives.AlignmentByteMask_64x65">
             <summary>Mask used to handle alignment elements before vectorized handling of the input.</summary>
             <remarks>
             Logically 64 rows of 64 bytes. The Nth row should be used to handle N alignment elements at the
             beginning of the input, where elements in the vector after that will be zero'd.
            
             There actually exists 65 rows in the table with the last row being a repeat of the first. This is
             done because it allows the main algorithms to use a simplified algorithm when computing the amount
             of misalignment where we always skip the first 64 elements, even if already aligned, so we don't
             double process them. This allows us to avoid an additional branch.
             </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.TensorPrimitives.AlignmentUInt16Mask_32x33">
             <summary>Mask used to handle alignment elements before vectorized handling of the input.</summary>
             <remarks>
             Logically 32 rows of 32 uints. The Nth row should be used to handle N alignment elements at the
             beginning of the input, where elements in the vector after that will be zero'd.
            
             There actually exists 33 rows in the table with the last row being a repeat of the first. This is
             done because it allows the main algorithms to use a simplified algorithm when computing the amount
             of misalignment where we always skip the first 32 elements, even if already aligned, so we don't
             double process them. This allows us to avoid an additional branch.
             </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.TensorPrimitives.AlignmentUInt32Mask_16x17">
             <summary>Mask used to handle alignment elements before vectorized handling of the input.</summary>
             <remarks>
             Logically 16 rows of 16 uints. The Nth row should be used to handle N alignment elements at the
             beginning of the input, where elements in the vector after that will be zero'd.
            
             There actually exists 17 rows in the table with the last row being a repeat of the first. This is
             done because it allows the main algorithms to use a simplified algorithm when computing the amount
             of misalignment where we always skip the first 16 elements, even if already aligned, so we don't
             double process them. This allows us to avoid an additional branch.
             </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.TensorPrimitives.AlignmentUInt64Mask_8x9">
             <summary>Mask used to handle alignment elements before vectorized handling of the input.</summary>
             <remarks>
             Logically 8 rows of 8 ulongs. The Nth row should be used to handle N alignment elements at the
             beginning of the input, where elements in the vector after that will be zero'd.
            
             There actually exists 9 rows in the table with the last row being a repeat of the first. This is
             done because it allows the main algorithms to use a simplified algorithm when computing the amount
             of misalignment where we always skip the first 8 elements, even if already aligned, so we don't
             double process them. This allows us to avoid an additional branch.
             </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.TensorPrimitives.RemainderByteMask_64x65">
             <summary>Mask used to handle remaining elements after vectorized handling of the input.</summary>
             <remarks>
             Logically 64 rows of 64 ushorts. The Nth row should be used to handle N remaining elements at the
             end of the input, where elements in the vector prior to that will be zero'd.
            
             Much as with the AlignmentMask table, we actually have 65 rows where the last row is a repeat of
             the first. Doing this allows us to avoid an additional branch and instead to always process the
             last 16 elements via a conditional select instead.
             </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.TensorPrimitives.RemainderUInt16Mask_32x33">
             <summary>Mask used to handle remaining elements after vectorized handling of the input.</summary>
             <remarks>
             Logically 32 rows of 32 ushorts. The Nth row should be used to handle N remaining elements at the
             end of the input, where elements in the vector prior to that will be zero'd.
            
             Much as with the AlignmentMask table, we actually have 33 rows where the last row is a repeat of
             the first. Doing this allows us to avoid an additional branch and instead to always process the
             last 16 elements via a conditional select instead.
             </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.TensorPrimitives.RemainderUInt32Mask_16x17">
             <summary>Mask used to handle remaining elements after vectorized handling of the input.</summary>
             <remarks>
             Logically 16 rows of 16 uints. The Nth row should be used to handle N remaining elements at the
             end of the input, where elements in the vector prior to that will be zero'd.
            
             Much as with the AlignmentMask table, we actually have 17 rows where the last row is a repeat of
             the first. Doing this allows us to avoid an additional branch and instead to always process the
             last 16 elements via a conditional select instead.
             </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.TensorPrimitives.RemainderUInt64Mask_8x9">
             <summary>Mask used to handle remaining elements after vectorized handling of the input.</summary>
             <remarks>
             Logically 8 rows of 8 ulongs. The Nth row should be used to handle N remaining elements at the
             end of the input, where elements in the vector prior to that will be zero'd.
            
             Much as with the AlignmentMask table, we actually have 9 rows where the last row is a repeat of
             the first. Doing this allows us to avoid an additional branch and instead to always process the
             last 8 elements via a conditional select instead.
             </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IAggregationOperator`1">
            <summary><see cref="T:System.Numerics.Tensors.TensorPrimitives.IBinaryOperator`1"/> that specializes horizontal aggregation of all elements in a vector.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Aggregate``3(System.ReadOnlySpan{``0})">
            <summary>Performs an aggregation over all elements in <paramref name="x"/> to produce a single-precision floating-point value.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TTransformOperator">Specifies the transform operation that should be applied to each element loaded from <paramref name="x"/>.</typeparam>
            <typeparam name="TAggregationOperator">
            Specifies the aggregation binary operation that should be applied to multiple values to aggregate them into a single value.
            The aggregation is applied after the transform is applied to each element.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Aggregate``3(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Performs an aggregation over all pair-wise elements in <paramref name="x"/> and <paramref name="y"/> to produce a single-precision floating-point value.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TBinaryOperator">Specifies the binary operation that should be applied to the pair-wise elements loaded from <paramref name="x"/> and <paramref name="y"/>.</typeparam>
            <typeparam name="TAggregationOperator">
            Specifies the aggregation binary operation that should be applied to multiple values to aggregate them into a single value.
            The aggregation is applied to the results of the binary operations on the pair-wise values.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CreateAlignmentMaskVector128``1(System.Int32)">
            <summary>
            Gets a vector mask that will be all-ones-set for the last <paramref name="count"/> elements
            and zero for all other elements.
            </summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CreateAlignmentMaskVector256``1(System.Int32)">
            <summary>
            Gets a vector mask that will be all-ones-set for the last <paramref name="count"/> elements
            and zero for all other elements.
            </summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CreateAlignmentMaskVector512``1(System.Int32)">
            <summary>
            Gets a vector mask that will be all-ones-set for the last <paramref name="count"/> elements
            and zero for all other elements.
            </summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CreateRemainderMaskVector128``1(System.Int32)">
            <summary>
            Gets a vector mask that will be all-ones-set for the last <paramref name="count"/> elements
            and zero for all other elements.
            </summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CreateRemainderMaskVector256``1(System.Int32)">
            <summary>
            Gets a vector mask that will be all-ones-set for the last <paramref name="count"/> elements
            and zero for all other elements.
            </summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CreateRemainderMaskVector512``1(System.Int32)">
            <summary>
            Gets a vector mask that will be all-ones-set for the last <paramref name="count"/> elements
            and zero for all other elements.
            </summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IBinaryOperator`1">
            <summary>Operator that takes two input values and returns a single value.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeScalarSpanIntoSpan``2(``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/> and <paramref name="y"/>,
            and writes the results to <paramref name="destination"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TBinaryOperator">
            Specifies the operation to perform on each element loaded from <paramref name="x"/> with <paramref name="y"/>.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanScalarIntoSpan``2(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/> and <paramref name="y"/>,
            and writes the results to <paramref name="destination"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TBinaryOperator">
            Specifies the operation to perform on each element loaded from <paramref name="x"/> with <paramref name="y"/>.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanSpanIntoSpan``2(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/> and <paramref name="y"/>,
            and writes the results to <paramref name="destination"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TBinaryOperator{T}{T}">
            Specifies the operation to perform on the pair-wise elements loaded from <paramref name="x"/> and <paramref name="y"/>.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanScalarIntoSpan``3(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/> and <paramref name="y"/>,
            and writes the results to <paramref name="destination"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TTransformOperator">
            Specifies the operation to perform on each element loaded from <paramref name="x"/>.
            It is not used with <paramref name="y"/>.
            </typeparam>
            <typeparam name="TBinaryOperator">
            Specifies the operation to perform on the transformed value from <paramref name="x"/> with <paramref name="y"/>.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.HorizontalAggregate``2(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Aggregates all of the elements in the <paramref name="x"/> into a single value.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TAggregate">Specifies the operation to be performed on each pair of values.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.HorizontalAggregate``2(System.Runtime.Intrinsics.Vector512{``0})">
            <summary>Aggregates all of the elements in the <paramref name="x"/> into a single value.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TAggregate">Specifies the operation to be performed on each pair of values.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.HorizontalAggregate``2(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Aggregates all of the elements in the <paramref name="x"/> into a single value.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TAggregate">Specifies the operation to be performed on each pair of values.</typeparam>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IStatefulUnaryOperator`1">
            <summary>Operator that takes one input value and returns a single value.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanIntoSpan``2(System.ReadOnlySpan{``0},``1,System.Span{``0})">
            <summary>Performs an element-wise operation on <paramref name="x"/> and writes the results to <paramref name="destination"/>.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TStatefulUnaryOperator">Specifies the operation to perform on each element loaded from <paramref name="x"/>.</typeparam>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ITernaryOperator`1">
            <summary>Operator that takes three input values and returns a single value.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanSpanSpanIntoSpan``2(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/>, <paramref name="y"/>, and <paramref name="z"/>,
            and writes the results to <paramref name="destination"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TTernaryOperator">
            Specifies the operation to perform on the pair-wise elements loaded from <paramref name="x"/>, <paramref name="y"/>,
            and <paramref name="z"/>.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanSpanScalarIntoSpan``2(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/>, <paramref name="y"/>, and <paramref name="z"/>,
            and writes the results to <paramref name="destination"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TTernaryOperator">
            Specifies the operation to perform on the pair-wise elements loaded from <paramref name="x"/> and <paramref name="y"/>
            with <paramref name="z"/>.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanScalarSpanIntoSpan``2(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/>, <paramref name="y"/>, and <paramref name="z"/>,
            and writes the results to <paramref name="destination"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TTernaryOperator">
            Specifies the operation to perform on the pair-wise element loaded from <paramref name="x"/>, with <paramref name="y"/>,
            and the element loaded from <paramref name="z"/>.
            </typeparam>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IUnaryInputBinaryOutput`1">
            <summary>Operator that takes one input value and returns two output values.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanIntoSpan_TwoOutputs``2(System.ReadOnlySpan{``0},System.Span{``0},System.Span{``0})">
            <summary>Performs an element-wise operation on <paramref name="x"/> and writes the results to <paramref name="destination1"/> and <paramref name="destination2"/>.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TUnaryOperator">Specifies the operation to perform on each element loaded from <paramref name="x"/>.</typeparam>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IUnaryOneToTwoOperator`2">
            <summary>Operator that takes one input value and returns a single value.</summary>
            <remarks>The input type must be half the size of the output type.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanIntoSpan_1to2``3(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>Performs an element-wise operation on <paramref name="x"/> and writes the results to <paramref name="destination"/>.</summary>
            <typeparam name="TInput">The element input type.</typeparam>
            <typeparam name="TOutput">The element output type. Must be the same size as TInput if TInput and TOutput both support vectorization.</typeparam>
            <typeparam name="TUnaryOperator">Specifies the operation to perform on each element loaded from <paramref name="x"/>.</typeparam>
            <remarks>This should only be used when it's known that TInput/TOutput are vectorizable and the size of TInput is half that of TOutput.</remarks>
        </member>
        <member name="F:System.Numerics.Tensors.TensorPrimitives.NonTemporalByteThreshold">
             <summary>Defines the threshold, in bytes, at which non-temporal stores will be used.</summary>
             <remarks>
                 A non-temporal store is one that allows the CPU to bypass the cache when writing to memory.
            
                 This can be beneficial when working with large amounts of memory where the writes would otherwise
                 cause large amounts of repeated updates and evictions. The hardware optimization manuals recommend
                 the threshold to be roughly half the size of the last level of on-die cache -- that is, if you have approximately
                 4MB of L3 cache per core, you'd want this to be approx. 1-2MB, depending on if hyperthreading was enabled.
            
                 However, actually computing the amount of L3 cache per core can be tricky or error prone. Native memcpy
                 algorithms use a constant threshold that is typically around 256KB and we match that here for simplicity. This
                 threshold accounts for most processors in the last 10-15 years that had approx. 1MB L3 per core and support
                 hyperthreading, giving a per core last level cache of approx. 512KB.
             </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IUnaryOperator`2">
            <summary>Operator that takes one input value and returns a single value.</summary>
            <remarks>The input and output type must be of the same size if vectorization is desired.</remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IdentityOperator`1">
            <summary>x</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanIntoSpan``2(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Performs an element-wise operation on <paramref name="x"/> and writes the results to <paramref name="destination"/>.</summary>
            <typeparam name="T">The element input type.</typeparam>
            <typeparam name="TUnaryOperator">Specifies the operation to perform on each element loaded from <paramref name="x"/>.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanIntoSpan``3(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>Performs an element-wise operation on <paramref name="x"/> and writes the results to <paramref name="destination"/>.</summary>
            <typeparam name="TInput">The element input type.</typeparam>
            <typeparam name="TOutput">The element output type. Must be the same size as TInput if TInput and TOutput both support vectorization.</typeparam>
            <typeparam name="TUnaryOperator">Specifies the operation to perform on each element loaded from <paramref name="x"/>.</typeparam>
            <remarks>
            This supports vectorizing the operation if <typeparamref name="TInput"/> and <typeparamref name="TOutput"/> are the same size.
            Otherwise, it'll fall back to scalar operations.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Rename``2(System.Span{``0})">
            <summary>Creates a span of <typeparamref name="TTo"/> from a <typeparamref name="TTo"/> when they're the same type.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IUnaryTwoToOneOperator`2">
            <summary>Operator that takes one input value and returns a single value.</summary>
            <remarks>The input type must be twice the size of the output type.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanIntoSpan_2to1``3(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>Performs an element-wise operation on <paramref name="x"/> and writes the results to <paramref name="destination"/>.</summary>
            <typeparam name="TInput">The element input type.</typeparam>
            <typeparam name="TOutput">The element output type. Must be the same size as TInput if TInput and TOutput both support vectorization.</typeparam>
            <typeparam name="TUnaryOperator">Specifies the operation to perform on each element loaded from <paramref name="x"/>.</typeparam>
            <remarks>This should only be used when it's known that TInput/TOutput are vectorizable and the size of TInput is twice that of TOutput.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Abs``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise absolute value of each number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.OverflowException"><typeparamref name="T"/> is a signed integer type and <paramref name="x"/> contained a value equal to <typeparamref name="T"/>'s minimum value.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Abs(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The absolute value of a <typeparamref name="T"/> is its numeric value without its sign. For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.
            </para>
            <para>
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/> or <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>.
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result stored into the corresponding destination location is the original NaN value with the sign bit removed.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AbsoluteOperator`1">
            <summary>T.Abs(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Acos``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise angle in radians whose cosine is the specifed number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Acos(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AcosOperator`1">
            <summary>T.Acos(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Acosh``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise hyperbolic arc-cosine of the specifed number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Acosh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AcoshOperator`1">
            <summary>T.Acosh(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AcosPi``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise angle in radians whose cosine is the specifed number and divides the result by Pi.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.AcosPi(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AcosPiOperator`1">
            <summary>T.AcosPi(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Add``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise addition of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Add``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise addition of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + <paramref name="y" /></c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AddOperator`1">
            <summary>x + y</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="multiplier">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" /> and the length of <paramref name="multiplier" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="multiplier"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />[i]) * <paramref name="multiplier" />[i]</c>.
            </para>
            <para>
            If any of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="multiplier">The third tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />[i]) * <paramref name="multiplier" /></c>.
            </para>
            <para>
            If any of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="multiplier">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="multiplier" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="multiplier"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />) * <paramref name="multiplier" />[i]</c>.
            </para>
            <para>
            If any of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AddMultiplyOperator`1">
            <summary>(x + y) * z</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Asin``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise angle in radians whose sine is the specifed number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Asin(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AsinOperator`1">
            <summary>T.Asin(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Asinh``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise hyperbolic arc-sine of the specifed number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Asinh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AsinhOperator`1">
            <summary>T.Asinh(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AsinPi``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise angle in radians whose sine is the specifed number and divides the result by Pi.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.AsinPi(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AsinPiOperator`1">
            <summary>T.AsinPi(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Atan``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise angle in radians whose tangent is the specifed number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Atan(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AtanOperator`1">
            <summary>T.Atan(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Atan2``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors.</summary>
            <param name="y">The first tensor, represented as a span.</param>
            <param name="x">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="y" /> must be same as length of <paramref name="x" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Atan2(<paramref name="y" />[i], <paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Atan2``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors.</summary>
            <param name="y">The first tensor, represented as a span.</param>
            <param name="x">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Atan2(<paramref name="y" />[i], <paramref name="x" />)</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Atan2``1(``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors.</summary>
            <param name="y">The first tensor, represented as a scalar.</param>
            <param name="x">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Atan2(<paramref name="y" />, <paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Atan2Operator`1">
            <summary>T.Atan2(y, x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Atan2Pi``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors and divides the result by Pi.</summary>
            <param name="y">The first tensor, represented as a span.</param>
            <param name="x">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="y" /> must be same as length of <paramref name="x" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Atan2(<paramref name="y" />[i], <paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Atan2Pi``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors and divides the result by Pi.</summary>
            <param name="y">The first tensor, represented as a span.</param>
            <param name="x">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Atan2(<paramref name="y" />[i], <paramref name="x" />)</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Atan2Pi``1(``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors and divides the result by Pi.</summary>
            <param name="y">The first tensor, represented as a scalar.</param>
            <param name="x">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Atan2(<paramref name="y" />, <paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Atan2PiOperator`1">
            <summary>T.Atan2Pi(y, x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Atanh``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise hyperbolic arc-tangent of the specifed number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Atanh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AtanhOperator`1">
            <summary>T.Atanh(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AtanPi``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise angle in radians whose tangent is the specifed number and divides the result by Pi.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.AtanPi(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AtanPiOperator`1">
            <summary>T.AtanPi(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.BitwiseAnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise bitwise AND of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &amp; <paramref name="y" />[i]</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.BitwiseAnd``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise bitwise AND of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &amp; <paramref name="y" /></c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.BitwiseAndOperator`1">
            <summary>x &amp; y</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.BitwiseOr``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise bitwise OR of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] | <paramref name="y" />[i]</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.BitwiseOr``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise bitwise OR of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] | <paramref name="y" /></c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.BitwiseOrOperator`1">
            <summary>x | y</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Cbrt``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise cube root of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Cbrt(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.CbrtOperator`1">
            <summary>T.Cbrt(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Ceiling``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise ceiling of numbers in the specified tensor.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Ceiling(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ConvertChecked``2(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>
            Copies <paramref name="source"/> to <paramref name="destination"/>, converting each <typeparamref name="TFrom"/>
            value to a <typeparamref name="TTo"/> value.
            </summary>
            <param name="source">The source span from which to copy values.</param>
            <param name="destination">The destination span into which the converted values should be written.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = TTo.CreateChecked(<paramref name="source"/>[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertCheckedFallbackOperator`2">
            <summary>T.CreateChecked(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.TryConvertUniversal``2(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>Performs conversions that are the same regardless of checked, truncating, or saturation.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertInt32ToSingle">
            <summary>(int)float</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertUInt32ToSingle">
            <summary>(uint)float</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertUInt64ToDouble">
            <summary>(double)ulong</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertInt64ToDouble">
            <summary>(double)long</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.WidenSingleToDoubleOperator">
            <summary>(double)float</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.NarrowDoubleToSingleOperator">
            <summary>(float)double</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.WidenByteToUInt16Operator">
            <summary>(ushort)byte</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.WidenSByteToInt16Operator">
            <summary>(short)sbyte</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.WidenUInt16ToUInt32Operator">
            <summary>(uint)ushort</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.WidenInt16ToInt32Operator">
            <summary>(int)short</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.WidenUInt32ToUInt64Operator">
            <summary>(ulong)uint</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.WidenInt32ToInt64Operator">
            <summary>(long)int</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Rename``2(System.ReadOnlySpan{``0})">
            <summary>Creates a span of <typeparamref name="TTo"/> from a <typeparamref name="TTo"/> when they're the same type.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsUInt32Like``1">
            <summary>Gets whether <typeparamref name="T"/> is <see cref="T:System.UInt32"/> or <see cref="T:System.UIntPtr"/> if in a 32-bit process.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsInt32Like``1">
            <summary>Gets whether <typeparamref name="T"/> is <see cref="T:System.Int32"/> or <see cref="T:System.IntPtr"/> if in a 32-bit process.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsUInt64Like``1">
            <summary>Gets whether <typeparamref name="T"/> is <see cref="T:System.UInt64"/> or <see cref="T:System.UIntPtr"/> if in a 64-bit process.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsInt64Like``1">
            <summary>Gets whether <typeparamref name="T"/> is <see cref="T:System.Int64"/> or <see cref="T:System.IntPtr"/> if in a 64-bit process.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ConvertSaturating``2(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>
            Copies <paramref name="source"/> to <paramref name="destination"/>, converting each <typeparamref name="TFrom"/>
            value to a <typeparamref name="TTo"/> value.
            </summary>
            <param name="source">The source span from which to copy values.</param>
            <param name="destination">The destination span into which the converted values should be written.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = TTo.CreateSaturating(<paramref name="source"/>[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertSaturatingFallbackOperator`2">
            <summary>T.CreateSaturating(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ConvertTruncating``2(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>
            Copies <paramref name="source"/> to <paramref name="destination"/>, converting each <typeparamref name="TFrom"/>
            value to a <typeparamref name="TTo"/> value.
            </summary>
            <param name="source">The source span from which to copy values.</param>
            <param name="destination">The destination span into which the converted values should be written.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = TTo.CreateTruncating(<paramref name="source"/>[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertSingleToInt32">
            <summary>(float)int</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertSingleToUInt32">
            <summary>(float)uint</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertDoubleToUInt64">
            <summary>(ulong)double</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertDoubleToInt64">
            <summary>(long)double</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.NarrowUInt16ToByteOperator">
            <summary>(byte)ushort</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.NarrowInt16ToSByteOperator">
            <summary>(sbyte)short</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.NarrowUInt32ToUInt16Operator">
            <summary>(ushort)uint</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.NarrowInt32ToInt16Operator">
            <summary>(short)int</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.NarrowUInt64ToUInt32Operator">
            <summary>(uint)ulong</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.NarrowInt64ToInt32Operator">
            <summary>(int)long</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertTruncatingFallbackOperator`2">
            <summary>T.CreateTruncating(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CopySign``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of copying the sign from one number to another number in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="sign">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="sign" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="sign"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.CopySign(<paramref name="x" />[i], <paramref name="sign" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CopySign``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise result of copying the sign from one number to another number in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="sign">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.CopySign(<paramref name="x" />[i], <paramref name="sign" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Cos``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise cosine of the value in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Cos(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians"/> or multiply by <typeparamref name="T"/>.Pi/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.CosOperator`1">
            <summary>T.Cos(x)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.CosOperatorSingle">
            <summary>float.Cos(x)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.CosOperatorDouble">
            <summary>double.Cos(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Cosh``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise hyperbolic cosine of each radian angle in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Cosh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/> or <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>.
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result stored into the corresponding destination location is also NaN.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians"/> or multiply by <typeparamref name="T"/>.Pi/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.CoshOperator`1">
            <summary>T.Cosh(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CosineSimilarity``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Computes the cosine similarity between the two specified non-empty, equal-length tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The cosine similarity of the two tensors.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
            <remarks>
            <para>
            This method effectively computes <c>TensorPrimitives.Dot(x, y) / (<typeparamref name="T"/>.Sqrt(TensorPrimitives.SumOfSquares(x)) * <typeparamref name="T"/>.Sqrt(TensorPrimitives.SumOfSquares(y)).</c>
            </para>
            <para>
            If any element in either input tensor is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>, <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>, or <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>,
            NaN is returned.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CosineSimilarityCore``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Computes the cosine similarity between the two specified non-empty, equal-length tensors of single-precision floating-point numbers.</summary>
            <remarks>Assumes arguments have already been validated to be non-empty and equal length.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CosPi``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise cosine of the value in the specified tensor that has been multiplied by Pi.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.CosPi(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians"/> or multiply by <typeparamref name="T"/>.Pi/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.CosPiOperator`1">
            <summary>T.CosPi(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.DegreesToRadians``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise conversion of each number of degrees in the specified tensor to radiansx.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.DegreesToRadians(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.DegreesToRadiansOperator`1">
            <summary>T.DegreesToRadians(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Distance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Computes the distance between two points, specified as non-empty, equal-length tensors of numbers, in Euclidean space.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The Euclidean distance.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
            <remarks>
            <para>
            This method effectively computes the equivalent of:
            <c>
                Span&lt;T&gt; difference = ...;
                TensorPrimitives.Subtract(x, y, difference);
                T result = <typeparamref name="T"/>.Sqrt(TensorPrimitives.SumOfSquares(difference));
            </c>
            but without requiring additional temporary storage for the intermediate differences.
            </para>
            <para>
            If any element in either input tensor is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, NaN is returned.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SubtractSquaredOperator`1">
            <summary>(x - y) * (x - y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Divide``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise division of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and an element in <paramref name="y"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] / <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Divide``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise division of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and <paramref name="y"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] / <paramref name="y" /></c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Divide``1(``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise division of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a scalar.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and an element in <paramref name="y"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" /> / <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.DivideOperator`1">
            <summary>x / y</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Dot``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Computes the dot product of two tensors containing numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The dot product.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <remarks>
            <para>
            This method effectively computes the equivalent of:
            <c>
                Span&lt;T&gt; products = ...;
                TensorPrimitives.Multiply(x, y, products);
                T result = TensorPrimitives.Sum(products);
            </c>
            but without requiring additional temporary storage for the intermediate products. It corresponds to the <c>dot</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If any of the input elements is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting value is also NaN.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Exp``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of raising <c>e</c> to the number powers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Exp(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/> or <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>, the result stored into the corresponding destination location is set to NaN.
            If a value equals <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>, the result stored into the corresponding destination location is set to 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ExpOperator`1">
            <summary>T.Exp(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Exp10``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of raising 10 to the number powers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Exp10(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Exp10Operator`1">
            <summary>T.Exp10(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Exp10M1``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of raising 10 to the number powers in the specified tensor, minus one.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Exp10M1(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Exp10M1Operator`1">
            <summary>T.Exp10M1(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Exp2``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Exp2(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Exp2Operator`1">
            <summary>T.Exp2(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Exp2M1``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor, minus one.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Exp2M1(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Exp2M1Operator`1">
            <summary>T.Exp2M1(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ExpM1``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of raising <c>e</c> to the number powers in the specified tensor, minus 1.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.ExpM1(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ExpM1Operator`1">
            <summary>T.ExpM1(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Floor``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise floor of numbers in the specified tensor.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Floor(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) * <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="addend">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" /> and length of <paramref name="addend" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="addend"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            <para>
            This computes (<paramref name="x"/> * <paramref name="y"/>) as if to infinite precision, adds <paramref name="addend"/> to that result as if to
            infinite precision, and finally rounds to the nearest representable value. This differs from the non-fused sequence which would compute
            (<paramref name="x"/> * <paramref name="y"/>) as if to infinite precision, round the result to the nearest representable value, add <paramref name="addend"/> to the
            rounded result as if to infinite precision, and finally round to the nearest representable value.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) * <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="addend">The third tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" /></c>.
            It corresponds to the <c>axpy</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            <para>
            This computes (<paramref name="x"/> * <paramref name="y"/>) as if to infinite precision, adds <paramref name="addend"/> to that result as if to
            infinite precision, and finally rounds to the nearest representable value. This differs from the non-fused sequence which would compute
            (<paramref name="x"/> * <paramref name="y"/>) as if to infinite precision, round the result to the nearest representable value, add <paramref name="addend"/> to the
            rounded result as if to infinite precision, and finally round to the nearest representable value.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) * <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="addend">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="addend" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="addend"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />) + <paramref name="addend" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            <para>
            This computes (<paramref name="x"/> * <paramref name="y"/>) as if to infinite precision, adds <paramref name="addend"/> to that result as if to
            infinite precision, and finally rounds to the nearest representable value. This differs from the non-fused sequence which would compute
            (<paramref name="x"/> * <paramref name="y"/>) as if to infinite precision, round the result to the nearest representable value, add <paramref name="addend"/> to the
            rounded result as if to infinite precision, and finally round to the nearest representable value.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAddOperator`1">
            <summary>(x * y) + z</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ConvertToHalf(System.ReadOnlySpan{System.Single},System.Span{System.Half})">
            <summary>
            Copies <paramref name="source"/> to <paramref name="destination"/>, converting each <see cref="T:System.Single" />
            value to its nearest representable half-precision floating-point value.
            </summary>
            <param name="source">The source span from which to copy values.</param>
            <param name="destination">The destination span into which the converted values should be written.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (Half)<paramref name="source" />[i]</c>.
            </para>
            <para>
            <paramref name="source"/> and <paramref name="destination"/> must not overlap. If they do, behavior is undefined.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ConvertToSingle(System.ReadOnlySpan{System.Half},System.Span{System.Single})">
            <summary>
            Copies <paramref name="source"/> to <paramref name="destination"/>, converting each half-precision
            floating-point value to its nearest representable <see cref="T:System.Single"/> value.
            </summary>
            <param name="source">The source span from which to copy values.</param>
            <param name="destination">The destination span into which the converted values should be written.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (float)<paramref name="source" />[i]</c>.
            </para>
            <para>
            <paramref name="source"/> and <paramref name="destination"/> must not overlap. If they do, behavior is undefined.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Hypot``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise hypotensue given values from two tensors representing the lengths of the shorter sides in a right-angled triangle.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Hypot(<paramref name="x" />[i], <paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.HypotOperator`1">
            <summary>T.Hypot(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Ieee754Remainder(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Ieee754Remainder(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder``1(``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a scalar.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Ieee754Remainder(<paramref name="x" />, <paramref name="y" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Ieee754RemainderOperator`1">
            <summary>T.Ieee754Remainder(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ILogB``1(System.ReadOnlySpan{``0},System.Span{System.Int32})">
            <summary>Computes the element-wise integer logarithm of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.ILogB(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ILogBOperator`1">
            <summary>T.ILogB(x)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ILogBDoubleOperator">
            <summary>double.ILogB(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMax``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the index of the largest number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The index of the maximum element in <paramref name="x"/>, or -1 if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If any value equal to NaN
            is present, the index of the first is returned. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IndexOfMaxOperator`1">
            <summary>Returns the index of MathF.Max(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNegative``1(``0)">
            <summary>Gets whether the specified <see cref="T:System.Single"/> is negative.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMaxMagnitude``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the index of the number with the largest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The index of the element in <paramref name="x"/> with the largest magnitude (absolute value), or -1 if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitude` function. If any value equal to NaN
            is present, the index of the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMin``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the index of the smallest number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The index of the minimum element in <paramref name="x"/>, or -1 if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimum` function. If any value equal to NaN
            is present, the index of the first is returned. Negative 0 is considered smaller than positive 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IndexOfMinOperator`1">
            <summary>Returns the index of MathF.Min(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMinMagnitude``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the index of the number with the smallest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The index of the element in <paramref name="x"/> with the smallest magnitude (absolute value), or -1 if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If any value equal to NaN
            is present, the index of the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.LeadingZeroCount``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise leading zero count of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.LeadingZeroCount(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.LeadingZeroCountOperator`1">
            <summary>T.LeadingZeroCount(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Lerp``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise linear interpolation between two values based on the given weight in the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="amount">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" /> and length of <paramref name="amount" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="amount"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Lerp(<paramref name="x" />[i], <paramref name="y" />[i], <paramref name="amount" />[i])</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Lerp``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise linear interpolation between two values based on the given weight in the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="amount">The third tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Lerp(<paramref name="x" />[i], <paramref name="y" />[i], <paramref name="amount" />)</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Lerp``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise linear interpolation between two values based on the given weight in the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="amount">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="amount" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="amount"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Lerp(<paramref name="x" />[i], <paramref name="y" />, <paramref name="amount" />[i])</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.LerpOperator`1">
            <summary>(x * (1 - z)) + (y * z)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise natural (base <c>e</c>) logarithm of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Log(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>.
            Otherwise, if a value is positive, its natural logarithm is stored into the corresponding destination location.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise logarithm of the numbers in a specified tensor to the specified base in another specified tensor.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Log(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise logarithm of the numbers in a specified tensor to the specified base in another specified tensor.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Log(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.LogOperator`1">
            <summary>T.Log(x)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.LogBaseOperator`1">
            <summary>T.Log(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log10``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise base 10 logarithm of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Log10(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>.
            Otherwise, if a value is positive, its base 10 logarithm is stored into the corresponding destination location.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Log10Operator`1">
            <summary>T.Log10(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log10P1``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise base 10 logarithm of numbers in the specified tensor plus 1.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Log10P1(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>.
            Otherwise, if a value is positive, its base 10 logarithm plus 1 is stored into the corresponding destination location.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Log10P1Operator`1">
            <summary>T.Log10P1(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log2``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise base 2 logarithm of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Log2(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>.
            Otherwise, if a value is positive, its base 2 logarithm is stored into the corresponding destination location.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Log2Operator`1">
            <summary>T.Log2(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log2P1``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise base 2 logarithm of numbers in the specified tensor plus 1.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Log2P1(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>.
            Otherwise, if a value is positive, its base 2 logarithm plus 1 is stored into the corresponding destination location.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Log2P1Operator`1">
            <summary>T.Log2P1(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.LogP1``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise natural (base <c>e</c>) logarithm of numbers in the specified tensor plus 1.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.LogP1(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>.
            Otherwise, if a value is positive, its natural logarithm plus 1 is stored into the corresponding destination location.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.LogP1Operator`1">
            <summary>T.LogP1(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Max``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the largest number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The maximum element in <paramref name="x"/>.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If any value equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>
            is present, the first is returned. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Max``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Max(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Max``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Max(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MaxOperator`1">
            <summary>T.Max(x, y) (but NaNs may not be propagated)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MaxPropagateNaNOperator`1">
            <summary>Max(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNegative``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Gets whether each specified <see cref="T:System.Single"/> is negative.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNegative``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Gets whether each specified <see cref="T:System.Single"/> is negative.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNegative``1(System.Runtime.Intrinsics.Vector512{``0})">
            <summary>Gets whether each specified <see cref="T:System.Single"/> is negative.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinMaxCore``2(System.ReadOnlySpan{``0})">
            <remarks>
            This is the same as <see cref="M:System.Numerics.Tensors.TensorPrimitives.Aggregate``3(System.ReadOnlySpan{``0})"/>
            with an identity transform, except it early exits on NaN.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the number with the largest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The element in <paramref name="x"/> with the largest magnitude (absolute value).</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitude` function. If any value equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>
            is present, the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.MaxMagnitude(<paramref name="x" />[i], <paramref name="y" />[i])</c>.</remarks>
            <remarks>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.MaxMagnitude(<paramref name="x" />[i], <paramref name="y" />)</c>.</remarks>
            <remarks>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Min``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the smallest number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The minimum element in <paramref name="x"/>.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimum` function. If any value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>
            is present, the first is returned. Negative 0 is considered smaller than positive 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeOperator`1">
            <summary>Operator to get x or y based on which has the larger MathF.Abs (but NaNs may not be propagated)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MaxMagnitudePropagateNaNOperator`1">
            <summary>Operator to get x or y based on which has the larger MathF.Abs</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Min``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Max(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Min``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Max(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MinOperator`1">
            <summary>T.Min(x, y) (but NaNs may not be propagated)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MinPropagateNaNOperator`1">
            <summary>T.Min(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the number with the smallest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The element in <paramref name="x"/> with the smallest magnitude (absolute value).</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If any value equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>
            is present, the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.MinMagnitude(<paramref name="x" />[i], <paramref name="y" />[i])</c>.</remarks>
            <remarks>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>,
            that value is stored as the result. If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.MinMagnitude(<paramref name="x" />[i], <paramref name="y" />)</c>.</remarks>
            <remarks>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>,
            that value is stored as the result. If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MinMagnitudeOperator`1">
            <summary>Operator to get x or y based on which has the smaller MathF.Abs (but NaNs may not be propagated)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MinMagnitudePropagateNaNOperator`1">
            <summary>Operator to get x or y based on which has the smaller MathF.Abs</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Multiply``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise product of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] * <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Multiply``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise product of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] * <paramref name="y" /></c>.
            It corresponds to the <c>scal</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MultiplyOperator`1">
            <summary>x * y</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) * <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="addend">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" /> and length of <paramref name="addend" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="addend"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) * <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="addend">The third tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" /></c>.
            It corresponds to the <c>axpy</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) * <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="addend">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="addend" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="addend"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />) + <paramref name="addend" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MultiplyAddOperator`1">
            <summary>(x * y) + z</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) * <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="addend">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" /> and length of <paramref name="addend" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="addend"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            <para>
            Behaves the same as either <see cref="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})"/> or
            <see cref="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})"/> depending on the current machine's capabilities.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) * <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="addend">The third tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" /></c>.
            It corresponds to the <c>axpy</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            <para>
            Behaves the same as either <see cref="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})"/> or
            <see cref="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})"/> depending on the current machine's capabilities.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) * <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="addend">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="addend" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="addend"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />) + <paramref name="addend" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            <para>
            Behaves the same as either <see cref="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})"/> or
            <see cref="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})"/> depending on the current machine's capabilities.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimateOperator`1">
            <summary>(x * y) + z</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Negate``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise negation of each number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = -<paramref name="x" />[i]</c>.
            </para>
            <para>
            If any of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.NegateOperator`1">
            <summary>-x</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Norm``1(System.ReadOnlySpan{``0})">
            <summary>Computes the Euclidean norm of the specified tensor of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <returns>The norm.</returns>
            <remarks>
            <para>
            This method effectively computes <c><typeparamref name="T"/>.Sqrt(TensorPrimitives.SumOfSquares(x))</c>.
            This is often referred to as the Euclidean norm or L2 norm.
            It corresponds to the <c>nrm2</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If any of the input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result value is also NaN.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.OnesComplement``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise one's complement of numbers in the specified tensor.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = ~<paramref name="x" />[i]</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.OnesComplementOperator`1">
            <summary>~x</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.PopCount``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise population count of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.PopCount(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.PopCountOperator`1">
            <summary>T.PopCount(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Pow``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Pow(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Pow``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Pow(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Pow``1(``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
            <param name="x">The first tensor, represented as a scalar.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Pow(<paramref name="x" />, <paramref name="y" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.PowOperator`1">
            <summary>T.Pow(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Product``1(System.ReadOnlySpan{``0})">
            <summary>Computes the product of all elements in the specified non-empty tensor of numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The result of multiplying all elements in <paramref name="x"/>.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            If any of the input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result value is also NaN.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ProductOfDifferences``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Computes the product of the element-wise differences of the numbers in the specified non-empty tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The result of multiplying the element-wise subtraction of the elements in the second tensor from the first tensor.</returns>
            <exception cref="T:System.ArgumentException">Length of both input spans must be greater than zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="y"/> must have the same length.</exception>
            <remarks>
            <para>
            This method effectively computes:
            <c>
                Span&lt;T&gt; differences = ...;
                TensorPrimitives.Subtract(x, y, differences);
                T result = TensorPrimitives.Product(differences);
            </c>
            but without requiring additional temporary storage for the intermediate differences.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ProductOfSums``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Computes the product of the element-wise sums of the numbers in the specified non-empty tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The result of multiplying the element-wise additions of the elements in each tensor.</returns>
            <exception cref="T:System.ArgumentException">Length of both input spans must be greater than zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="y"/> must have the same length.</exception>
            <remarks>
            <para>
            This method effectively computes:
            <c>
                Span&lt;T&gt; sums = ...;
                TensorPrimitives.Add(x, y, sums);
                T result = TensorPrimitives.Product(sums);
            </c>
            but without requiring additional temporary storage for the intermediate sums.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.RadiansToDegrees``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise conversion of each number of radians in the specified tensor to degrees.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.RadiansToDegrees(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.RadiansToDegreesOperator`1">
            <summary>T.RadiansToDegrees(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Reciprocal``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise reciprocal of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and an element in <paramref name="x"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1 / <paramref name="x" />[i]</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ReciprocalEstimate``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise reciprocal of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and an element in <paramref name="x"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1 / <paramref name="x" />[i]</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ReciprocalSqrt``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise reciprocal of the square root of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and an element in <paramref name="x"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1 / <paramref name="x" />[i]</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ReciprocalSqrtEstimate``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise reciprocal of the square root of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and an element in <paramref name="x"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1 / <paramref name="x" />[i]</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.RootN``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})">
            <summary>Computes the element-wise n-th root of the values in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <param name="n">The degree of the root to be computed, represented as a scalar.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.RootN(<paramref name="x" />[i], <paramref name="n"/>)</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.RootNOperator`1">
            <summary>T.RootN(x, n)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.RootNOperator`1.#ctor(System.Int32)">
            <summary>T.RootN(x, n)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.RotateLeft``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})">
            <summary>Computes the element-wise rotation left of numbers in the specified tensor by the specified rotation amount.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <param name="rotateAmount">The number of bits to rotate, represented as a scalar.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.RotateLeft(<paramref name="x" />[i], <paramref name="rotateAmount"/>)</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.RotateRight``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})">
            <summary>Computes the element-wise rotation right of numbers in the specified tensor by the specified rotation amount.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <param name="rotateAmount">The number of bits to rotate, represented as a scalar.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.RotateRight(<paramref name="x" />[i], <paramref name="rotateAmount"/>)</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.RotateLeftOperator`1">
            <summary>T.RotateLeft(amount)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.RotateLeftOperator`1.#ctor(System.Int32)">
            <summary>T.RotateLeft(amount)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.RotateRightOperator`1">
            <summary>T.RotateRight(amount)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.RotateRightOperator`1.#ctor(System.Int32)">
            <summary>T.RotateRight(amount)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Round``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Round(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Round``1(System.ReadOnlySpan{``0},System.MidpointRounding,System.Span{``0})">
            <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="mode">The mode under which <paramref name="x" /> should be rounded.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Round(<paramref name="x" />[i], <paramref name="mode"/>)</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Round``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})">
            <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="digits">The number of fractional digits to which the numbers in <paramref name="x" /> should be rounded.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Round(<paramref name="x" />[i], <paramref name="digits"/>)</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Round``1(System.ReadOnlySpan{``0},System.Int32,System.MidpointRounding,System.Span{``0})">
            <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="digits">The number of fractional digits to which the numbers in <paramref name="x" /> should be rounded.</param>
            <param name="mode">The mode under which <paramref name="x" /> should be rounded.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="digits"/> is invalid.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="mode"/> is invalid.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Round(<paramref name="x" />[i], <paramref name="digits"/>, <paramref name="mode"/>)</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.RoundToEvenOperator`1">
            <summary>T.Round(x)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.RoundAwayFromZeroOperator`1">
            <summary>T.Round(x, MidpointRounding.AwayFromZero)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MultiplyRoundDivideOperator`2">
            <summary>(T.Round(x * power10, digits, mode)) / power10</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.RoundFallbackOperator`1">
            <summary>T.Round(x, digits, mode)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.RoundFallbackOperator`1.#ctor(System.Int32,System.MidpointRounding)">
            <summary>T.Round(x, digits, mode)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ScaleB``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})">
            <summary>Computes the element-wise product of numbers in the specified tensor and their base-radix raised to the specified power.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="n">The value to which base-radix is raised before multipliying x, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.ILogB(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ScaleBOperator`1">
            <summary>T.ScaleB(x, n)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ScaleBOperator`1.#ctor(System.Int32)">
            <summary>T.ScaleB(x, n)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ShiftLeft``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})">
            <summary>Computes the element-wise shifting left of numbers in the specified tensor by the specified shift amount.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <param name="shiftAmount">The number of bits to shift, represented as a scalar.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &lt;&lt; <paramref name="shiftAmount"/></c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ShiftRightArithmetic``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})">
            <summary>Computes the element-wise arithmetic (signed) shifting right of numbers in the specified tensor by the specified shift amount.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <param name="shiftAmount">The number of bits to shift, represented as a scalar.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &gt;&gt; <paramref name="shiftAmount"/></c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ShiftRightLogical``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})">
            <summary>Computes the element-wise logical (unsigned) shifting right of numbers in the specified tensor by the specified shift amount.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <param name="shiftAmount">The number of bits to shift, represented as a scalar.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &gt;&gt;&gt; <paramref name="shiftAmount"/></c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ShiftLeftOperator`1">
            <summary>T &lt;&lt; amount</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ShiftLeftOperator`1.#ctor(System.Int32)">
            <summary>T &lt;&lt; amount</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ShiftRightArithmeticOperator`1">
            <summary>T &gt;&gt; amount</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ShiftRightArithmeticOperator`1.#ctor(System.Int32)">
            <summary>T &gt;&gt; amount</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ShiftRightLogicalOperator`1">
            <summary>T &gt;&gt;&gt; amount</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ShiftRightLogicalOperator`1.#ctor(System.Int32)">
            <summary>T &gt;&gt;&gt; amount</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sigmoid``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise sigmoid function on the specified non-empty tensor of numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> must not be empty.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1f / (1f + <typeparamref name="T"/>.Exp(-<paramref name="x" />[i]))</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SigmoidOperator`1">
            <summary>1 / (1 + T.Exp(-x))</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sin``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise sine of the value in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Sin(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians"/> or multiply by <typeparamref name="T"/>.Pi/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SinOperator`1">
            <summary>T.Sin(x)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SinOperatorSingle">
            <summary>float.Sin(x)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SinOperatorDouble">
            <summary>double.Sin(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SinCos``1(System.ReadOnlySpan{``0},System.Span{``0},System.Span{``0})">
            <summary>Computes the element-wise sine and cosine of the value in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="sinDestination">The destination tensor for the element-wise sine result, represented as a span.</param>
            <param name="cosDestination">The destination tensor for the element-wise cosine result, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="sinDestination"/> or <paramref name="cosDestination" /> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c>(<paramref name="sinDestination" />[i], <paramref name="cosDestination" />[i]) = <typeparamref name="T"/>.SinCos(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SinCosOperator`1">
            <summary>T.SinCos(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SinCosPi``1(System.ReadOnlySpan{``0},System.Span{``0},System.Span{``0})">
            <summary>Computes the element-wise sine and cosine of the value in the specified tensor that has been multiplied by Pi.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="sinPiDestination">The destination tensor for the element-wise sine result, represented as a span.</param>
            <param name="cosPiDestination">The destination tensor for the element-wise cosine result, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="sinPiDestination"/> or <paramref name="cosPiDestination" /> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c>(<paramref name="sinPiDestination" />[i], <paramref name="cosPiDestination" />[i]) = <typeparamref name="T"/>.SinCos(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SinCosPiOperator`1">
            <summary>T.SinCosPi(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sinh``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise hyperbolic sine of each radian angle in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Sinh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>, <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>, or <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>,
            the corresponding destination location is set to that value.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians"/> or multiply by <typeparamref name="T"/>.Pi / 180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SinhOperator`1">
            <summary>T.Sinh(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SinPi``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise sine of the value in the specified tensor that has been multiplied by Pi.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.SinPi(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians"/> or multiply by <typeparamref name="T"/>.Pi/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SinPiOperator`1">
            <summary>T.SinPi(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SoftMax``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the softmax function over the specified non-empty tensor of numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> must not be empty.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes a sum of <c><typeparamref name="T"/>.Exp(x[i])</c> for all elements in <paramref name="x"/>.
            It then effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Exp(<paramref name="x" />[i]) / sum</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sqrt``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise square root of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Sqrt(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SqrtOperator`1">
            <summary>T.Sqrt(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Subtract``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise difference between numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Subtract``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise difference between numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - <paramref name="y" /></c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Subtract``1(``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise difference between numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a scalar.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" /> - <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SubtractOperator`1">
            <summary>x - y</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sum``1(System.ReadOnlySpan{``0})">
            <summary>Computes the sum of all elements in the specified tensor of numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The result of adding all elements in <paramref name="x"/>, or zero if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            If any of the values in the input is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result is also NaN.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SumOfMagnitudes``1(System.ReadOnlySpan{``0})">
            <summary>Computes the sum of the absolute values of every element in the specified tensor of numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The result of adding the absolute value of every element in <paramref name="x"/>, or zero if <paramref name="x"/> is empty.</returns>
            <exception cref="T:System.OverflowException"><typeparamref name="T"/> is a signed integer type and <paramref name="x"/> contained a value equal to <typeparamref name="T"/>'s minimum value.</exception>
            <remarks>
            <para>
            This method effectively computes:
            <c>
                Span&lt;T&gt; absoluteValues = ...;
                TensorPrimitives.Abs(x, absoluteValues);
                T result = TensorPrimitives.Sum(absoluteValues);
            </c>
            but without requiring intermediate storage for the absolute values. It corresponds to the <c>asum</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SumOfSquares``1(System.ReadOnlySpan{``0})">
            <summary>Computes the sum of the square of every element in the specified tensor of numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The result of adding the square of every element in <paramref name="x"/>, or zero if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            This method effectively computes:
            <c>
                Span&lt;T&gt; squaredValues = ...;
                TensorPrimitives.Multiply(x, x, squaredValues);
                T result = TensorPrimitives.Sum(squaredValues);
            </c>
            but without requiring intermediate storage for the squared values.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SquaredOperator`1">
            <summary>x * x</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Tan``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise tangent of the value in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Tan(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians"/> or multiply by <typeparamref name="T"/>.Pi/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.TanOperator`1">
            <summary>T.Tan(x)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.TanOperatorSingle">
            <summary>float.Tan(x)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.TanOperatorDouble">
            <summary>double.Tan(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Tanh``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise hyperbolic tangent of each radian angle in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Tanh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>, the corresponding destination location is set to -1.
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>, the corresponding destination location is set to 1.
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the corresponding destination location is set to NaN.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians"/> or multiply by <typeparamref name="T"/>.Pi / 180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.TanhOperator`1">
            <summary>T.Tanh(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.TanPi``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise tangent of the value in the specified tensor that has been multiplied by Pi.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.TanPi(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians"/> or multiply by <typeparamref name="T"/>.Pi/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.TanPiOperator`1">
            <summary>T.TanPi(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.TrailingZeroCount``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise trailing zero count of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.TrailingZeroCount(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.TrailingZeroCountOperator`1">
            <summary>T.TrailingZeroCount(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Truncate``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise truncation of numbers in the specified tensor.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Truncate(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Xor``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise XOR of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] ^ <paramref name="y" />[i]</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Xor``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise XOR of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] ^ <paramref name="y" /></c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.XorOperator`1">
            <summary>x ^ y</summary>
        </member>
        <member name="P:System.SR.Argument_DestinationTooShort">
            <summary>Destination is too short.</summary>
        </member>
        <member name="P:System.SR.Argument_SpansMustBeNonEmpty">
            <summary>Input span arguments must not be empty.</summary>
        </member>
        <member name="P:System.SR.Argument_SpansMustHaveSameLength">
            <summary>Input span arguments must all have the same length.</summary>
        </member>
        <member name="P:System.SR.Argument_InputAndDestinationSpanMustNotOverlap">
            <summary>The destination span may only overlap with an input span if the two spans start at the same memory location.</summary>
        </member>
        <member name="P:System.SR.Overflow_NegateTwosCompNum">
            <summary>Negating the minimum value of a twos complement number is invalid.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidEnumValue">
            <summary>The value '{0}' is not valid for this usage of the type {1}.</summary>
        </member>
    </members>
</doc>
